const VERBOSE = false;

const fs = require('fs');
const {iru, eru} = require('./utils');
const {loadWords} = require('./node-utils');

// Slurp the dictionary
const words = loadWords();

const godan = [];
const ichidan = [];

// Make a list of entries that are godan or ichidan that end in る
for (const word of words) {
  const isVerb = word.sense.some(
      (sense) => sense.partOfSpeech.some(
          (pos) => pos.startsWith('v5') || pos === 'v1'));
  // going to ignore zuru `vz` verbs
  if (isVerb) {
    const texts = word.kana.concat(word.kanji).map((k) => k.text);
    const endsInRu = texts.some((t) => t.endsWith('る'));
    if (endsInRu) {
      const isGodan = word.sense.some(
          (sense) => sense.partOfSpeech.some((pos) => pos.startsWith('v5')));
      (isGodan ? godan : ichidan).push(word);
    }
  }
}

const toTexts = (arr) =>
    new Set(arr.flatMap((w) => w.kana.concat(w.kanji)).map((k) => k.text));

const [godanTexts, ichidanTexts] = [godan, ichidan].map(toTexts);
if (VERBOSE) {
  console.log(godan.length, ichidan.length);
  console.log([godanTexts, ichidanTexts].map((s) => s.size));
}

const [godanTextsNonIruEru, ichidanTextsNonIruEru] = [
  godanTexts,
  ichidanTexts,
].map((set) => Array.from(set).filter((s) => !(iru(s) || eru(s))));
if (VERBOSE) {
  console.log(
      'non-iru-eru', godanTextsNonIruEru.length, ichidanTextsNonIruEru.length);
}

const ichidanNonIruEruEndings =
    new Set(ichidanTextsNonIruEru.map((s) => s.slice(-2)));
const tmp = new Set(godanTextsNonIruEru);
const both = ichidanTextsNonIruEru.filter((text) => tmp.has(text));
if (VERBOSE) {
  console.log('ichidan endings', ichidanNonIruEruEndings.size);
  console.log('both', both);
}
const bothSet = new Set(both);

fs.writeFileSync(
    'nonIruEru.js',
    `// NOTA BENE: this file is auto-generated by analysis.js.
// To recreate it, run "npm run analysis"

const ichidan = new Set(${
        JSON.stringify(
            Array.from(ichidanTextsNonIruEru.filter((s) => !bothSet.has(s))))});

const both = new Set(${JSON.stringify(both)});

module.exports = {ichidan, both};`);

// Iru/Eru
const [godanTextsIruEru, ichidanTextsIruEru] = [godanTexts, ichidanTexts].map(
    (set) => Array.from(set).filter((s) => iru(s) || eru(s)));
if (VERBOSE) {
  console.log(
      'WITH-iru-eru', godanTextsIruEru.length, ichidanTextsIruEru.length);
  console.log('godan with iru-eru');
  console.log(godanTextsIruEru.slice(0, 100).join(' '));
}
const tmp2 = new Set(ichidanTextsIruEru);
const bothIruEru = godanTextsIruEru.filter((v) => tmp2.has(v));
const bothIruEruSet = new Set(bothIruEru);
if (VERBOSE) {
  console.log(bothIruEru);
}
fs.writeFileSync(
    'iruEru.js',
    `// NOTA BENE: this file is auto-generated by analysis.js.
// To recreate it, run "npm run analysis"

const godan = new Set(${
        JSON.stringify(godanTextsIruEru.filter((s) => !bothIruEruSet.has(s)))});

const both = new Set(${JSON.stringify(bothIruEru)});

module.exports = {godan, both};`);
